// Package cmaoapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package cmaoapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for FeatureType.
const (
	FeatureTypeFeature FeatureType = "Feature"
)

// Defines values for FeatureCollectionType.
const (
	FeatureCollectionTypeFeatureCollection FeatureCollectionType = "FeatureCollection"
)

// Defines values for GeometryType.
const (
	GeometryTypeGeometryCollection GeometryType = "GeometryCollection"
	GeometryTypeLineString         GeometryType = "LineString"
	GeometryTypeMultiLineString    GeometryType = "MultiLineString"
	GeometryTypeMultiPoint         GeometryType = "MultiPoint"
	GeometryTypeMultiPolygon       GeometryType = "MultiPolygon"
	GeometryTypePoint              GeometryType = "Point"
	GeometryTypePolygon            GeometryType = "Polygon"
)

// Defines values for AssetArchiveExtractionStatus.
const (
	Done       AssetArchiveExtractionStatus = "done"
	Failed     AssetArchiveExtractionStatus = "failed"
	InProgress AssetArchiveExtractionStatus = "in_progress"
	Pending    AssetArchiveExtractionStatus = "pending"
)

// Defines values for AssetPreviewType.
const (
	Csv        AssetPreviewType = "csv"
	Geo        AssetPreviewType = "geo"
	Geo3dTiles AssetPreviewType = "geo_3d_Tiles"
	GeoMvt     AssetPreviewType = "geo_mvt"
	Image      AssetPreviewType = "image"
	ImageSvg   AssetPreviewType = "image_svg"
	Model3d    AssetPreviewType = "model_3d"
	Unknown    AssetPreviewType = "unknown"
)

// Defines values for AssetEmbedding.
const (
	All   AssetEmbedding = "all"
	False AssetEmbedding = "false"
	True  AssetEmbedding = "true"
)

// Defines values for CommentAuthorType.
const (
	Integrtaion CommentAuthorType = "integrtaion"
	User        CommentAuthorType = "user"
)

// Defines values for ConditionBasicOperator.
const (
	ConditionBasicOperatorEquals    ConditionBasicOperator = "equals"
	ConditionBasicOperatorNotEquals ConditionBasicOperator = "notEquals"
)

// Defines values for ConditionBoolOperator.
const (
	ConditionBoolOperatorEquals    ConditionBoolOperator = "equals"
	ConditionBoolOperatorNotEquals ConditionBoolOperator = "notEquals"
)

// Defines values for ConditionMultipleOperator.
const (
	IncludesAll    ConditionMultipleOperator = "includesAll"
	IncludesAny    ConditionMultipleOperator = "includesAny"
	NotIncludesAll ConditionMultipleOperator = "notIncludesAll"
	NotIncludesAny ConditionMultipleOperator = "notIncludesAny"
)

// Defines values for ConditionNullableOperator.
const (
	Empty    ConditionNullableOperator = "empty"
	NotEmpty ConditionNullableOperator = "notEmpty"
)

// Defines values for ConditionNumberOperator.
const (
	GreaterThan          ConditionNumberOperator = "greaterThan"
	GreaterThanOrEqualTo ConditionNumberOperator = "greaterThanOrEqualTo"
	LessThan             ConditionNumberOperator = "lessThan"
	LessThanOrEqualTo    ConditionNumberOperator = "lessThanOrEqualTo"
)

// Defines values for ConditionStringOperator.
const (
	Contains      ConditionStringOperator = "contains"
	EndsWith      ConditionStringOperator = "endsWith"
	NotContains   ConditionStringOperator = "notContains"
	NotEndsWith   ConditionStringOperator = "notEndsWith"
	NotStartsWith ConditionStringOperator = "notStartsWith"
	StartsWith    ConditionStringOperator = "startsWith"
)

// Defines values for ConditionTimeOperator.
const (
	After       ConditionTimeOperator = "after"
	AfterOrOn   ConditionTimeOperator = "afterOrOn"
	Before      ConditionTimeOperator = "before"
	BeforeOrOn  ConditionTimeOperator = "beforeOrOn"
	OfThisMonth ConditionTimeOperator = "ofThisMonth"
	OfThisWeek  ConditionTimeOperator = "ofThisWeek"
	OfThisYear  ConditionTimeOperator = "ofThisYear"
)

// Defines values for FieldSelectorType.
const (
	FieldSelectorTypeCreationDate     FieldSelectorType = "creationDate"
	FieldSelectorTypeCreationUser     FieldSelectorType = "creationUser"
	FieldSelectorTypeField            FieldSelectorType = "field"
	FieldSelectorTypeId               FieldSelectorType = "id"
	FieldSelectorTypeMetaField        FieldSelectorType = "metaField"
	FieldSelectorTypeModificationDate FieldSelectorType = "modificationDate"
	FieldSelectorTypeModificationUser FieldSelectorType = "modificationUser"
	FieldSelectorTypeStatus           FieldSelectorType = "status"
)

// Defines values for ValueType.
const (
	ValueTypeAsset          ValueType = "asset"
	ValueTypeBool           ValueType = "bool"
	ValueTypeCheckbox       ValueType = "checkbox"
	ValueTypeDate           ValueType = "date"
	ValueTypeGeometryEditor ValueType = "geometryEditor"
	ValueTypeGeometryObject ValueType = "geometryObject"
	ValueTypeGroup          ValueType = "group"
	ValueTypeInteger        ValueType = "integer"
	ValueTypeMarkdown       ValueType = "markdown"
	ValueTypeNumber         ValueType = "number"
	ValueTypeReference      ValueType = "reference"
	ValueTypeRichText       ValueType = "richText"
	ValueTypeSelect         ValueType = "select"
	ValueTypeTag            ValueType = "tag"
	ValueTypeText           ValueType = "text"
	ValueTypeTextArea       ValueType = "textArea"
	ValueTypeUrl            ValueType = "url"
)

// Defines values for RefParam.
const (
	RefParamLatest RefParam = "latest"
	RefParamPublic RefParam = "public"
)

// Defines values for SortDirParam.
const (
	SortDirParamAsc  SortDirParam = "asc"
	SortDirParamDesc SortDirParam = "desc"
)

// Defines values for SortParam.
const (
	SortParamCreatedAt SortParam = "createdAt"
	SortParamUpdatedAt SortParam = "updatedAt"
)

// Defines values for ItemGetParamsRef.
const (
	ItemGetParamsRefLatest ItemGetParamsRef = "latest"
	ItemGetParamsRefPublic ItemGetParamsRef = "public"
)

// Defines values for ModelImportJSONBodyFormat.
const (
	ModelImportJSONBodyFormatGeoJson ModelImportJSONBodyFormat = "geoJson"
	ModelImportJSONBodyFormatJson    ModelImportJSONBodyFormat = "json"
)

// Defines values for ModelImportJSONBodyStrategy.
const (
	ModelImportJSONBodyStrategyInsert ModelImportJSONBodyStrategy = "insert"
	ModelImportJSONBodyStrategyUpdate ModelImportJSONBodyStrategy = "update"
	ModelImportJSONBodyStrategyUpsert ModelImportJSONBodyStrategy = "upsert"
)

// Defines values for ModelImportMultipartBodyFormat.
const (
	ModelImportMultipartBodyFormatGeoJson ModelImportMultipartBodyFormat = "geoJson"
	ModelImportMultipartBodyFormatJson    ModelImportMultipartBodyFormat = "json"
)

// Defines values for ModelImportMultipartBodyStrategy.
const (
	ModelImportMultipartBodyStrategyInsert ModelImportMultipartBodyStrategy = "insert"
	ModelImportMultipartBodyStrategyUpdate ModelImportMultipartBodyStrategy = "update"
	ModelImportMultipartBodyStrategyUpsert ModelImportMultipartBodyStrategy = "upsert"
)

// Defines values for ItemFilterParamsSort.
const (
	ItemFilterParamsSortCreatedAt ItemFilterParamsSort = "createdAt"
	ItemFilterParamsSortUpdatedAt ItemFilterParamsSort = "updatedAt"
)

// Defines values for ItemFilterParamsDir.
const (
	ItemFilterParamsDirAsc  ItemFilterParamsDir = "asc"
	ItemFilterParamsDirDesc ItemFilterParamsDir = "desc"
)

// Defines values for ItemFilterParamsRef.
const (
	ItemFilterParamsRefLatest ItemFilterParamsRef = "latest"
	ItemFilterParamsRefPublic ItemFilterParamsRef = "public"
)

// Defines values for ItemsAsCSVParamsRef.
const (
	ItemsAsCSVParamsRefLatest ItemsAsCSVParamsRef = "latest"
	ItemsAsCSVParamsRefPublic ItemsAsCSVParamsRef = "public"
)

// Defines values for ItemsAsGeoJSONParamsRef.
const (
	ItemsAsGeoJSONParamsRefLatest ItemsAsGeoJSONParamsRef = "latest"
	ItemsAsGeoJSONParamsRefPublic ItemsAsGeoJSONParamsRef = "public"
)

// Defines values for ItemFilterWithProjectParamsSort.
const (
	ItemFilterWithProjectParamsSortCreatedAt ItemFilterWithProjectParamsSort = "createdAt"
	ItemFilterWithProjectParamsSortUpdatedAt ItemFilterWithProjectParamsSort = "updatedAt"
)

// Defines values for ItemFilterWithProjectParamsDir.
const (
	ItemFilterWithProjectParamsDirAsc  ItemFilterWithProjectParamsDir = "asc"
	ItemFilterWithProjectParamsDirDesc ItemFilterWithProjectParamsDir = "desc"
)

// Defines values for ItemFilterWithProjectParamsRef.
const (
	ItemFilterWithProjectParamsRefLatest ItemFilterWithProjectParamsRef = "latest"
	ItemFilterWithProjectParamsRefPublic ItemFilterWithProjectParamsRef = "public"
)

// Defines values for ItemsWithProjectAsCSVParamsRef.
const (
	ItemsWithProjectAsCSVParamsRefLatest ItemsWithProjectAsCSVParamsRef = "latest"
	ItemsWithProjectAsCSVParamsRefPublic ItemsWithProjectAsCSVParamsRef = "public"
)

// Defines values for ItemsWithProjectAsGeoJSONParamsRef.
const (
	ItemsWithProjectAsGeoJSONParamsRefLatest ItemsWithProjectAsGeoJSONParamsRef = "latest"
	ItemsWithProjectAsGeoJSONParamsRefPublic ItemsWithProjectAsGeoJSONParamsRef = "public"
)

// Defines values for AssetFilterParamsSort.
const (
	AssetFilterParamsSortCreatedAt AssetFilterParamsSort = "createdAt"
	AssetFilterParamsSortUpdatedAt AssetFilterParamsSort = "updatedAt"
)

// Defines values for AssetFilterParamsDir.
const (
	AssetFilterParamsDirAsc  AssetFilterParamsDir = "asc"
	AssetFilterParamsDirDesc AssetFilterParamsDir = "desc"
)

// Feature defines model for Feature.
type Feature struct {
	Geometry   *Geometry               `json:"geometry,omitempty"`
	Id         *string                 `json:"id,omitempty"`
	Properties *map[string]interface{} `json:"properties,omitempty"`
	Type       *FeatureType            `json:"type,omitempty"`
}

// FeatureType defines model for Feature.Type.
type FeatureType string

// FeatureCollection defines model for FeatureCollection.
type FeatureCollection struct {
	Features *[]Feature             `json:"features,omitempty"`
	Type     *FeatureCollectionType `json:"type,omitempty"`
}

// FeatureCollectionType defines model for FeatureCollection.Type.
type FeatureCollectionType string

// GeoJSON defines model for GeoJSON.
type GeoJSON = FeatureCollection

// Geometry defines model for Geometry.
type Geometry struct {
	Coordinates *Geometry_Coordinates `json:"coordinates,omitempty"`
	Geometries  *[]Geometry           `json:"geometries,omitempty"`
	Type        *GeometryType         `json:"type,omitempty"`
}

// Geometry_Coordinates defines model for Geometry.Coordinates.
type Geometry_Coordinates struct {
	union json.RawMessage
}

// GeometryType defines model for Geometry.Type.
type GeometryType string

// LineString defines model for LineString.
type LineString = []Point

// MultiLineString defines model for MultiLineString.
type MultiLineString = []LineString

// MultiPoint defines model for MultiPoint.
type MultiPoint = []Point

// MultiPolygon defines model for MultiPolygon.
type MultiPolygon = []Polygon

// Point defines model for Point.
type Point = []float64

// Polygon defines model for Polygon.
type Polygon = [][]Point

// Asset defines model for asset.
type Asset struct {
	ArchiveExtractionStatus *AssetArchiveExtractionStatus `json:"archiveExtractionStatus,omitempty"`
	ContentType             *string                       `json:"contentType,omitempty"`
	CreatedAt               time.Time                     `json:"createdAt"`
	File                    *File                         `json:"file,omitempty"`
	Id                      string                        `json:"id"`
	Name                    *string                       `json:"name,omitempty"`
	PreviewType             *AssetPreviewType             `json:"previewType,omitempty"`
	ProjectId               string                        `json:"projectId"`
	TotalSize               *float32                      `json:"totalSize,omitempty"`
	UpdatedAt               time.Time                     `json:"updatedAt"`
	Url                     string                        `json:"url"`
}

// AssetArchiveExtractionStatus defines model for Asset.ArchiveExtractionStatus.
type AssetArchiveExtractionStatus string

// AssetPreviewType defines model for Asset.PreviewType.
type AssetPreviewType string

// AssetEmbedding defines model for assetEmbedding.
type AssetEmbedding string

// Comment defines model for comment.
type Comment struct {
	AuthorId   *string            `json:"authorId,omitempty"`
	AuthorType *CommentAuthorType `json:"authorType,omitempty"`
	Content    *string            `json:"content,omitempty"`
	CreatedAt  *time.Time         `json:"createdAt,omitempty"`
	Id         *string            `json:"id,omitempty"`
}

// CommentAuthorType defines model for Comment.AuthorType.
type CommentAuthorType string

// Condition defines model for condition.
type Condition struct {
	And   *[]Condition `json:"and,omitempty"`
	Basic *struct {
		FieldId  *FieldSelector          `json:"fieldId,omitempty"`
		Operator *ConditionBasicOperator `json:"operator,omitempty"`
		Value    *interface{}            `json:"value,omitempty"`
	} `json:"basic,omitempty"`
	Bool *struct {
		FieldId  FieldSelector         `json:"fieldId"`
		Operator ConditionBoolOperator `json:"operator"`
		Value    bool                  `json:"value"`
	} `json:"bool,omitempty"`
	Multiple *struct {
		FieldId  FieldSelector             `json:"fieldId"`
		Operator ConditionMultipleOperator `json:"operator"`
		Value    []interface{}             `json:"value"`
	} `json:"multiple,omitempty"`
	Nullable *struct {
		FieldId  *FieldSelector             `json:"fieldId,omitempty"`
		Operator *ConditionNullableOperator `json:"operator,omitempty"`
	} `json:"nullable,omitempty"`
	Number *struct {
		FieldId  FieldSelector           `json:"fieldId"`
		Operator ConditionNumberOperator `json:"operator"`
		Value    float32                 `json:"value"`
	} `json:"number,omitempty"`
	Or     *[]Condition `json:"or,omitempty"`
	String *struct {
		FieldId  FieldSelector           `json:"fieldId"`
		Operator ConditionStringOperator `json:"operator"`
		Value    string                  `json:"value"`
	} `json:"string,omitempty"`
	Time *struct {
		FieldId  FieldSelector         `json:"fieldId"`
		Operator ConditionTimeOperator `json:"operator"`
		Value    time.Time             `json:"value"`
	} `json:"time,omitempty"`
}

// ConditionBasicOperator defines model for Condition.Basic.Operator.
type ConditionBasicOperator string

// ConditionBoolOperator defines model for Condition.Bool.Operator.
type ConditionBoolOperator string

// ConditionMultipleOperator defines model for Condition.Multiple.Operator.
type ConditionMultipleOperator string

// ConditionNullableOperator defines model for Condition.Nullable.Operator.
type ConditionNullableOperator string

// ConditionNumberOperator defines model for Condition.Number.Operator.
type ConditionNumberOperator string

// ConditionStringOperator defines model for Condition.String.Operator.
type ConditionStringOperator string

// ConditionTimeOperator defines model for Condition.Time.Operator.
type ConditionTimeOperator string

// Field defines model for field.
type Field struct {
	Group *string      `json:"group,omitempty"`
	Id    *string      `json:"id,omitempty"`
	Key   *string      `json:"key,omitempty"`
	Type  *ValueType   `json:"type,omitempty"`
	Value *interface{} `json:"value,omitempty"`
}

// FieldSelector defines model for fieldSelector.
type FieldSelector struct {
	FieldId *string            `json:"fieldId,omitempty"`
	Type    *FieldSelectorType `json:"type,omitempty"`
}

// FieldSelectorType defines model for FieldSelector.Type.
type FieldSelectorType string

// File defines model for file.
type File struct {
	Children    *[]File  `json:"children,omitempty"`
	ContentType *string  `json:"contentType,omitempty"`
	Name        *string  `json:"name,omitempty"`
	Path        *string  `json:"path,omitempty"`
	Size        *float32 `json:"size,omitempty"`
}

// Model defines model for model.
type Model struct {
	CreatedAt        *time.Time `json:"createdAt,omitempty"`
	Description      *string    `json:"description,omitempty"`
	Id               *string    `json:"id,omitempty"`
	Key              *string    `json:"key,omitempty"`
	LastModified     *time.Time `json:"lastModified,omitempty"`
	MetadataSchema   *Schema    `json:"metadataSchema,omitempty"`
	MetadataSchemaId *string    `json:"metadataSchemaId,omitempty"`
	Name             *string    `json:"name,omitempty"`
	ProjectId        *string    `json:"projectId,omitempty"`
	Public           *bool      `json:"public,omitempty"`
	Schema           *Schema    `json:"schema,omitempty"`
	SchemaId         *string    `json:"schemaId,omitempty"`
	UpdatedAt        *time.Time `json:"updatedAt,omitempty"`
}

// Project defines model for project.
type Project struct {
	Alias       *string    `json:"alias,omitempty"`
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	WorkspaceId *string    `json:"workspaceId,omitempty"`
}

// Schema defines model for schema.
type Schema struct {
	CreatedAt  *time.Time     `json:"createdAt,omitempty"`
	Fields     *[]SchemaField `json:"fields,omitempty"`
	Id         *string        `json:"id,omitempty"`
	ProjectId  *string        `json:"projectId,omitempty"`
	TitleField *string        `json:"titleField,omitempty"`
}

// SchemaField defines model for schemaField.
type SchemaField struct {
	Id       *string    `json:"id,omitempty"`
	Key      *string    `json:"key,omitempty"`
	Multiple *bool      `json:"multiple,omitempty"`
	Required *bool      `json:"required,omitempty"`
	Type     *ValueType `json:"type,omitempty"`
}

// SchemaJSON defines model for schemaJSON.
type SchemaJSON struct {
	Id          *string                         `json:"$id,omitempty"`
	Schema      *string                         `json:"$schema,omitempty"`
	Description *string                         `json:"description,omitempty"`
	Properties  map[string]SchemaJSONProperties `json:"properties"`
	Title       *string                         `json:"title,omitempty"`
	Type        string                          `json:"type"`
}

// SchemaJSONProperties defines model for schemaJSONProperties.
type SchemaJSONProperties struct {
	Description *string     `json:"description,omitempty"`
	Format      *string     `json:"format,omitempty"`
	Items       *SchemaJSON `json:"items,omitempty"`
	MaxLength   *int        `json:"maxLength,omitempty"`
	Maximum     *float64    `json:"maximum,omitempty"`
	Minimum     *float64    `json:"minimum,omitempty"`
	Title       *string     `json:"title,omitempty"`
	Type        string      `json:"type"`
}

// ValueType defines model for valueType.
type ValueType string

// VersionedItem defines model for versionedItem.
type VersionedItem struct {
	CreatedAt       *time.Time            `json:"createdAt,omitempty"`
	Fields          *[]Field              `json:"fields,omitempty"`
	Id              *string               `json:"id,omitempty"`
	IsMetadata      *bool                 `json:"isMetadata,omitempty"`
	MetadataFields  *[]Field              `json:"metadataFields,omitempty"`
	ModelId         *string               `json:"modelId,omitempty"`
	Parents         *[]openapi_types.UUID `json:"parents,omitempty"`
	ReferencedItems *[]VersionedItem      `json:"referencedItems,omitempty"`
	Refs            *[]string             `json:"refs,omitempty"`
	UpdatedAt       *time.Time            `json:"updatedAt,omitempty"`
	Version         *openapi_types.UUID   `json:"version,omitempty"`
}

// AssetIdParam defines model for assetIdParam.
type AssetIdParam = string

// AssetParam defines model for assetParam.
type AssetParam = AssetEmbedding

// CommentIdParam defines model for commentIdParam.
type CommentIdParam = string

// FieldIdOrKeyParam defines model for fieldIdOrKeyParam.
type FieldIdOrKeyParam = string

// ItemIdParam defines model for itemIdParam.
type ItemIdParam = string

// KeywordParam defines model for keywordParam.
type KeywordParam = string

// ModelIdOrKeyParam defines model for modelIdOrKeyParam.
type ModelIdOrKeyParam = string

// ModelIdParam defines model for modelIdParam.
type ModelIdParam = string

// PageParam defines model for pageParam.
type PageParam = int

// PerPageParam defines model for perPageParam.
type PerPageParam = int

// ProjectIdOrAliasParam defines model for projectIdOrAliasParam.
type ProjectIdOrAliasParam = string

// ProjectIdParam defines model for projectIdParam.
type ProjectIdParam = interface{}

// RefParam defines model for refParam.
type RefParam string

// SchemaIdParam defines model for schemaIdParam.
type SchemaIdParam = string

// SortDirParam defines model for sortDirParam.
type SortDirParam string

// SortParam defines model for sortParam.
type SortParam string

// WorkspaceIdParam defines model for workspaceIdParam.
type WorkspaceIdParam = interface{}

// AssetCommentCreateJSONBody defines parameters for AssetCommentCreate.
type AssetCommentCreateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// AssetCommentUpdateJSONBody defines parameters for AssetCommentUpdate.
type AssetCommentUpdateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// ItemGetParams defines parameters for ItemGet.
type ItemGetParams struct {
	// Ref Used to select a ref or ver
	Ref *ItemGetParamsRef `form:"ref,omitempty" json:"ref,omitempty"`

	// Asset Specifies whether asset data are embedded in the results
	Asset *AssetParam `form:"asset,omitempty" json:"asset,omitempty"`
}

// ItemGetParamsRef defines parameters for ItemGet.
type ItemGetParamsRef string

// ItemUpdateJSONBody defines parameters for ItemUpdate.
type ItemUpdateJSONBody struct {
	Asset          *AssetEmbedding `json:"asset,omitempty"`
	Fields         *[]Field        `json:"fields,omitempty"`
	MetadataFields *[]Field        `json:"metadataFields,omitempty"`
}

// ItemCommentCreateJSONBody defines parameters for ItemCommentCreate.
type ItemCommentCreateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// ItemCommentUpdateJSONBody defines parameters for ItemCommentUpdate.
type ItemCommentUpdateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// ModelUpdateJSONBody defines parameters for ModelUpdate.
type ModelUpdateJSONBody struct {
	Description *string `json:"description,omitempty"`
	Key         *string `json:"key,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// CopyModelJSONBody defines parameters for CopyModel.
type CopyModelJSONBody struct {
	Key  *string `json:"key,omitempty"`
	Name *string `json:"name,omitempty"`
}

// ModelImportJSONBody defines parameters for ModelImport.
type ModelImportJSONBody struct {
	AssetId          string                      `json:"assetId"`
	Format           ModelImportJSONBodyFormat   `json:"format"`
	GeometryFieldKey *string                     `json:"geometryFieldKey,omitempty"`
	MutateSchema     *bool                       `json:"mutateSchema,omitempty"`
	Strategy         ModelImportJSONBodyStrategy `json:"strategy"`
}

// ModelImportMultipartBody defines parameters for ModelImport.
type ModelImportMultipartBody struct {
	File             *openapi_types.File              `json:"file,omitempty"`
	Format           ModelImportMultipartBodyFormat   `json:"format"`
	GeometryFieldKey *string                          `json:"geometryFieldKey,omitempty"`
	MutateSchema     *bool                            `json:"mutateSchema,omitempty"`
	Strategy         ModelImportMultipartBodyStrategy `json:"strategy"`
}

// ModelImportJSONBodyFormat defines parameters for ModelImport.
type ModelImportJSONBodyFormat string

// ModelImportJSONBodyStrategy defines parameters for ModelImport.
type ModelImportJSONBodyStrategy string

// ModelImportMultipartBodyFormat defines parameters for ModelImport.
type ModelImportMultipartBodyFormat string

// ModelImportMultipartBodyStrategy defines parameters for ModelImport.
type ModelImportMultipartBodyStrategy string

// ItemFilterJSONBody defines parameters for ItemFilter.
type ItemFilterJSONBody struct {
	Filter *Condition `json:"filter,omitempty"`
}

// ItemFilterParams defines parameters for ItemFilter.
type ItemFilterParams struct {
	// Sort Used to define the order of the response list
	Sort *ItemFilterParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Dir Used to define the order direction of the response list, will be ignored if the order is not presented
	Dir *ItemFilterParamsDir `form:"dir,omitempty" json:"dir,omitempty"`

	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemFilterParamsRef `form:"ref,omitempty" json:"ref,omitempty"`

	// Asset Specifies whether asset data are embedded in the results
	Asset *AssetParam `form:"asset,omitempty" json:"asset,omitempty"`

	// Keyword keyword string
	Keyword *KeywordParam `form:"keyword,omitempty" json:"keyword,omitempty"`
}

// ItemFilterParamsSort defines parameters for ItemFilter.
type ItemFilterParamsSort string

// ItemFilterParamsDir defines parameters for ItemFilter.
type ItemFilterParamsDir string

// ItemFilterParamsRef defines parameters for ItemFilter.
type ItemFilterParamsRef string

// ItemCreateJSONBody defines parameters for ItemCreate.
type ItemCreateJSONBody struct {
	Fields         *[]Field `json:"fields,omitempty"`
	MetadataFields *[]Field `json:"metadataFields,omitempty"`
}

// ItemsAsCSVParams defines parameters for ItemsAsCSV.
type ItemsAsCSVParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemsAsCSVParamsRef `form:"ref,omitempty" json:"ref,omitempty"`
}

// ItemsAsCSVParamsRef defines parameters for ItemsAsCSV.
type ItemsAsCSVParamsRef string

// ItemsAsGeoJSONParams defines parameters for ItemsAsGeoJSON.
type ItemsAsGeoJSONParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemsAsGeoJSONParamsRef `form:"ref,omitempty" json:"ref,omitempty"`
}

// ItemsAsGeoJSONParamsRef defines parameters for ItemsAsGeoJSON.
type ItemsAsGeoJSONParamsRef string

// ModelFilterParams defines parameters for ModelFilter.
type ModelFilterParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// ModelCreateJSONBody defines parameters for ModelCreate.
type ModelCreateJSONBody struct {
	Description *string `json:"description,omitempty"`
	Key         *string `json:"key,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// ModelCreateParams defines parameters for ModelCreate.
type ModelCreateParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// ModelUpdateWithProjectJSONBody defines parameters for ModelUpdateWithProject.
type ModelUpdateWithProjectJSONBody struct {
	Description *string `json:"description,omitempty"`
	Key         *string `json:"key,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// FieldCreateWithProjectJSONBody defines parameters for FieldCreateWithProject.
type FieldCreateWithProjectJSONBody struct {
	Key      *string    `json:"key,omitempty"`
	Multiple *bool      `json:"multiple,omitempty"`
	Required *bool      `json:"required,omitempty"`
	Type     *ValueType `json:"type,omitempty"`
}

// FieldUpdateWithProjectJSONBody defines parameters for FieldUpdateWithProject.
type FieldUpdateWithProjectJSONBody struct {
	Key      *string    `json:"key,omitempty"`
	Multiple *bool      `json:"multiple,omitempty"`
	Required *bool      `json:"required,omitempty"`
	Type     *ValueType `json:"type,omitempty"`
}

// ItemFilterWithProjectParams defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParams struct {
	// Sort Used to define the order of the response list
	Sort *ItemFilterWithProjectParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Dir Used to define the order direction of the response list, will be ignored if the order is not presented
	Dir *ItemFilterWithProjectParamsDir `form:"dir,omitempty" json:"dir,omitempty"`

	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemFilterWithProjectParamsRef `form:"ref,omitempty" json:"ref,omitempty"`

	// Asset Specifies whether asset data are embedded in the results
	Asset *AssetParam `form:"asset,omitempty" json:"asset,omitempty"`
}

// ItemFilterWithProjectParamsSort defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParamsSort string

// ItemFilterWithProjectParamsDir defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParamsDir string

// ItemFilterWithProjectParamsRef defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParamsRef string

// ItemCreateWithProjectJSONBody defines parameters for ItemCreateWithProject.
type ItemCreateWithProjectJSONBody struct {
	Fields         *[]Field `json:"fields,omitempty"`
	MetadataFields *[]Field `json:"metadataFields,omitempty"`
}

// ItemsWithProjectAsCSVParams defines parameters for ItemsWithProjectAsCSV.
type ItemsWithProjectAsCSVParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemsWithProjectAsCSVParamsRef `form:"ref,omitempty" json:"ref,omitempty"`
}

// ItemsWithProjectAsCSVParamsRef defines parameters for ItemsWithProjectAsCSV.
type ItemsWithProjectAsCSVParamsRef string

// ItemsWithProjectAsGeoJSONParams defines parameters for ItemsWithProjectAsGeoJSON.
type ItemsWithProjectAsGeoJSONParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemsWithProjectAsGeoJSONParamsRef `form:"ref,omitempty" json:"ref,omitempty"`
}

// ItemsWithProjectAsGeoJSONParamsRef defines parameters for ItemsWithProjectAsGeoJSON.
type ItemsWithProjectAsGeoJSONParamsRef string

// SchemaFilterParams defines parameters for SchemaFilter.
type SchemaFilterParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Keyword keyword string
	Keyword *KeywordParam `form:"keyword,omitempty" json:"keyword,omitempty"`
}

// AssetFilterParams defines parameters for AssetFilter.
type AssetFilterParams struct {
	// Sort Used to define the order of the response list
	Sort *AssetFilterParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Dir Used to define the order direction of the response list, will be ignored if the order is not presented
	Dir *AssetFilterParamsDir `form:"dir,omitempty" json:"dir,omitempty"`

	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Keyword keyword string
	Keyword *KeywordParam `form:"keyword,omitempty" json:"keyword,omitempty"`
}

// AssetFilterParamsSort defines parameters for AssetFilter.
type AssetFilterParamsSort string

// AssetFilterParamsDir defines parameters for AssetFilter.
type AssetFilterParamsDir string

// AssetCreateJSONBody defines parameters for AssetCreate.
type AssetCreateJSONBody struct {
	SkipDecompression *bool   `json:"skipDecompression"`
	Token             *string `json:"token,omitempty"`
	Url               *string `json:"url,omitempty"`
}

// AssetCreateMultipartBody defines parameters for AssetCreate.
type AssetCreateMultipartBody struct {
	File              *openapi_types.File `json:"file,omitempty"`
	SkipDecompression *bool               `json:"skipDecompression,omitempty"`
}

// AssetUploadCreateJSONBody defines parameters for AssetUploadCreate.
type AssetUploadCreateJSONBody struct {
	ContentLength *int    `json:"contentLength,omitempty"`
	Cursor        *string `json:"cursor,omitempty"`
	Name          *string `json:"name,omitempty"`
}

// FieldCreateJSONBody defines parameters for FieldCreate.
type FieldCreateJSONBody struct {
	Key      *string    `json:"key,omitempty"`
	Multiple *bool      `json:"multiple,omitempty"`
	Required *bool      `json:"required,omitempty"`
	Type     *ValueType `json:"type,omitempty"`
}

// FieldUpdateJSONBody defines parameters for FieldUpdate.
type FieldUpdateJSONBody struct {
	Key      *string    `json:"key,omitempty"`
	Multiple *bool      `json:"multiple,omitempty"`
	Required *bool      `json:"required,omitempty"`
	Type     *ValueType `json:"type,omitempty"`
}

// ProjectFilterParams defines parameters for ProjectFilter.
type ProjectFilterParams struct {
	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// AssetCommentCreateJSONRequestBody defines body for AssetCommentCreate for application/json ContentType.
type AssetCommentCreateJSONRequestBody AssetCommentCreateJSONBody

// AssetCommentUpdateJSONRequestBody defines body for AssetCommentUpdate for application/json ContentType.
type AssetCommentUpdateJSONRequestBody AssetCommentUpdateJSONBody

// ItemUpdateJSONRequestBody defines body for ItemUpdate for application/json ContentType.
type ItemUpdateJSONRequestBody ItemUpdateJSONBody

// ItemCommentCreateJSONRequestBody defines body for ItemCommentCreate for application/json ContentType.
type ItemCommentCreateJSONRequestBody ItemCommentCreateJSONBody

// ItemCommentUpdateJSONRequestBody defines body for ItemCommentUpdate for application/json ContentType.
type ItemCommentUpdateJSONRequestBody ItemCommentUpdateJSONBody

// ModelUpdateJSONRequestBody defines body for ModelUpdate for application/json ContentType.
type ModelUpdateJSONRequestBody ModelUpdateJSONBody

// CopyModelJSONRequestBody defines body for CopyModel for application/json ContentType.
type CopyModelJSONRequestBody CopyModelJSONBody

// ModelImportJSONRequestBody defines body for ModelImport for application/json ContentType.
type ModelImportJSONRequestBody ModelImportJSONBody

// ModelImportMultipartRequestBody defines body for ModelImport for multipart/form-data ContentType.
type ModelImportMultipartRequestBody ModelImportMultipartBody

// ItemFilterJSONRequestBody defines body for ItemFilter for application/json ContentType.
type ItemFilterJSONRequestBody ItemFilterJSONBody

// ItemCreateJSONRequestBody defines body for ItemCreate for application/json ContentType.
type ItemCreateJSONRequestBody ItemCreateJSONBody

// ModelCreateJSONRequestBody defines body for ModelCreate for application/json ContentType.
type ModelCreateJSONRequestBody ModelCreateJSONBody

// ModelUpdateWithProjectJSONRequestBody defines body for ModelUpdateWithProject for application/json ContentType.
type ModelUpdateWithProjectJSONRequestBody ModelUpdateWithProjectJSONBody

// FieldCreateWithProjectJSONRequestBody defines body for FieldCreateWithProject for application/json ContentType.
type FieldCreateWithProjectJSONRequestBody FieldCreateWithProjectJSONBody

// FieldUpdateWithProjectJSONRequestBody defines body for FieldUpdateWithProject for application/json ContentType.
type FieldUpdateWithProjectJSONRequestBody FieldUpdateWithProjectJSONBody

// ItemCreateWithProjectJSONRequestBody defines body for ItemCreateWithProject for application/json ContentType.
type ItemCreateWithProjectJSONRequestBody ItemCreateWithProjectJSONBody

// AssetCreateJSONRequestBody defines body for AssetCreate for application/json ContentType.
type AssetCreateJSONRequestBody AssetCreateJSONBody

// AssetCreateMultipartRequestBody defines body for AssetCreate for multipart/form-data ContentType.
type AssetCreateMultipartRequestBody AssetCreateMultipartBody

// AssetUploadCreateJSONRequestBody defines body for AssetUploadCreate for application/json ContentType.
type AssetUploadCreateJSONRequestBody AssetUploadCreateJSONBody

// FieldCreateJSONRequestBody defines body for FieldCreate for application/json ContentType.
type FieldCreateJSONRequestBody FieldCreateJSONBody

// FieldUpdateJSONRequestBody defines body for FieldUpdate for application/json ContentType.
type FieldUpdateJSONRequestBody FieldUpdateJSONBody

// AsPoint returns the union data inside the Geometry_Coordinates as a Point
func (t Geometry_Coordinates) AsPoint() (Point, error) {
	var body Point
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoint overwrites any union data inside the Geometry_Coordinates as the provided Point
func (t *Geometry_Coordinates) FromPoint(v Point) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoint performs a merge with any union data inside the Geometry_Coordinates, using the provided Point
func (t *Geometry_Coordinates) MergePoint(v Point) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiPoint returns the union data inside the Geometry_Coordinates as a MultiPoint
func (t Geometry_Coordinates) AsMultiPoint() (MultiPoint, error) {
	var body MultiPoint
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiPoint overwrites any union data inside the Geometry_Coordinates as the provided MultiPoint
func (t *Geometry_Coordinates) FromMultiPoint(v MultiPoint) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiPoint performs a merge with any union data inside the Geometry_Coordinates, using the provided MultiPoint
func (t *Geometry_Coordinates) MergeMultiPoint(v MultiPoint) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLineString returns the union data inside the Geometry_Coordinates as a LineString
func (t Geometry_Coordinates) AsLineString() (LineString, error) {
	var body LineString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLineString overwrites any union data inside the Geometry_Coordinates as the provided LineString
func (t *Geometry_Coordinates) FromLineString(v LineString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLineString performs a merge with any union data inside the Geometry_Coordinates, using the provided LineString
func (t *Geometry_Coordinates) MergeLineString(v LineString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiLineString returns the union data inside the Geometry_Coordinates as a MultiLineString
func (t Geometry_Coordinates) AsMultiLineString() (MultiLineString, error) {
	var body MultiLineString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiLineString overwrites any union data inside the Geometry_Coordinates as the provided MultiLineString
func (t *Geometry_Coordinates) FromMultiLineString(v MultiLineString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiLineString performs a merge with any union data inside the Geometry_Coordinates, using the provided MultiLineString
func (t *Geometry_Coordinates) MergeMultiLineString(v MultiLineString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolygon returns the union data inside the Geometry_Coordinates as a Polygon
func (t Geometry_Coordinates) AsPolygon() (Polygon, error) {
	var body Polygon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolygon overwrites any union data inside the Geometry_Coordinates as the provided Polygon
func (t *Geometry_Coordinates) FromPolygon(v Polygon) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolygon performs a merge with any union data inside the Geometry_Coordinates, using the provided Polygon
func (t *Geometry_Coordinates) MergePolygon(v Polygon) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiPolygon returns the union data inside the Geometry_Coordinates as a MultiPolygon
func (t Geometry_Coordinates) AsMultiPolygon() (MultiPolygon, error) {
	var body MultiPolygon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiPolygon overwrites any union data inside the Geometry_Coordinates as the provided MultiPolygon
func (t *Geometry_Coordinates) FromMultiPolygon(v MultiPolygon) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiPolygon performs a merge with any union data inside the Geometry_Coordinates, using the provided MultiPolygon
func (t *Geometry_Coordinates) MergeMultiPolygon(v MultiPolygon) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Geometry_Coordinates) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Geometry_Coordinates) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AssetDelete request
	AssetDelete(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetGet request
	AssetGet(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentList request
	AssetCommentList(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentCreateWithBody request with any body
	AssetCommentCreateWithBody(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetCommentCreate(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentDelete request
	AssetCommentDelete(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentUpdateWithBody request with any body
	AssetCommentUpdateWithBody(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetCommentUpdate(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemDelete request
	ItemDelete(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemGet request
	ItemGet(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemUpdateWithBody request with any body
	ItemUpdateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemUpdate(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentList request
	ItemCommentList(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentCreateWithBody request with any body
	ItemCommentCreateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCommentCreate(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentDelete request
	ItemCommentDelete(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentUpdateWithBody request with any body
	ItemCommentUpdateWithBody(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCommentUpdate(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelDelete request
	ModelDelete(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelGet request
	ModelGet(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelUpdateWithBody request with any body
	ModelUpdateWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelUpdate(ctx context.Context, modelId ModelIdParam, body ModelUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyModelWithBody request with any body
	CopyModelWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyModel(ctx context.Context, modelId ModelIdParam, body CopyModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelImportWithBody request with any body
	ModelImportWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelImport(ctx context.Context, modelId ModelIdParam, body ModelImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemFilterWithBody request with any body
	ItemFilterWithBody(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemFilter(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, body ItemFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCreateWithBody request with any body
	ItemCreateWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCreate(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemsAsCSV request
	ItemsAsCSV(ctx context.Context, modelId ModelIdParam, params *ItemsAsCSVParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemsAsGeoJSON request
	ItemsAsGeoJSON(ctx context.Context, modelId ModelIdParam, params *ItemsAsGeoJSONParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataSchemaByModelAsJSON request
	MetadataSchemaByModelAsJSON(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemaByModelAsJSON request
	SchemaByModelAsJSON(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelFilter request
	ModelFilter(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelCreateWithBody request with any body
	ModelCreateWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelCreate(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, body ModelCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelDeleteWithProject request
	ModelDeleteWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelGetWithProject request
	ModelGetWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelUpdateWithProjectWithBody request with any body
	ModelUpdateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelUpdateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ModelUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FieldCreateWithProjectWithBody request with any body
	FieldCreateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FieldCreateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body FieldCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FieldDeleteWithProject request
	FieldDeleteWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FieldUpdateWithProjectWithBody request with any body
	FieldUpdateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FieldUpdateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemFilterWithProject request
	ItemFilterWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCreateWithProjectWithBody request with any body
	ItemCreateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCreateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemsWithProjectAsCSV request
	ItemsWithProjectAsCSV(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsCSVParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemsWithProjectAsGeoJSON request
	ItemsWithProjectAsGeoJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsGeoJSONParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataSchemaByModelWithProjectAsJSON request
	MetadataSchemaByModelWithProjectAsJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemaByModelWithProjectAsJSON request
	SchemaByModelWithProjectAsJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemaFilter request
	SchemaFilter(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *SchemaFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemaByIDWithProjectAsJSON request
	SchemaByIDWithProjectAsJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetFilter request
	AssetFilter(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCreateWithBody request with any body
	AssetCreateWithBody(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetCreate(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetUploadCreateWithBody request with any body
	AssetUploadCreateWithBody(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetUploadCreate(ctx context.Context, projectId ProjectIdParam, body AssetUploadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FieldCreateWithBody request with any body
	FieldCreateWithBody(ctx context.Context, schemaId SchemaIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FieldCreate(ctx context.Context, schemaId SchemaIdParam, body FieldCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FieldDelete request
	FieldDelete(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FieldUpdateWithBody request with any body
	FieldUpdateWithBody(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FieldUpdate(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemaByIDAsJSON request
	SchemaByIDAsJSON(ctx context.Context, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectFilter request
	ProjectFilter(ctx context.Context, workspaceId WorkspaceIdParam, params *ProjectFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AssetDelete(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetDeleteRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetGet(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetGetRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentList(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentListRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentCreateWithBody(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentCreateRequestWithBody(c.Server, assetId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentCreate(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentCreateRequest(c.Server, assetId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentDelete(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentDeleteRequest(c.Server, assetId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentUpdateWithBody(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentUpdateRequestWithBody(c.Server, assetId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentUpdate(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentUpdateRequest(c.Server, assetId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemDelete(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemDeleteRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemGet(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemGetRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemUpdateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemUpdateRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemUpdate(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemUpdateRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentList(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentListRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentCreateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentCreateRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentCreate(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentCreateRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentDelete(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentDeleteRequest(c.Server, itemId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentUpdateWithBody(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentUpdateRequestWithBody(c.Server, itemId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentUpdate(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentUpdateRequest(c.Server, itemId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelDelete(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelDeleteRequest(c.Server, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelGet(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelGetRequest(c.Server, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelUpdateWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelUpdateRequestWithBody(c.Server, modelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelUpdate(ctx context.Context, modelId ModelIdParam, body ModelUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelUpdateRequest(c.Server, modelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyModelWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyModelRequestWithBody(c.Server, modelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyModel(ctx context.Context, modelId ModelIdParam, body CopyModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyModelRequest(c.Server, modelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelImportWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelImportRequestWithBody(c.Server, modelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelImport(ctx context.Context, modelId ModelIdParam, body ModelImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelImportRequest(c.Server, modelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemFilterWithBody(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemFilterRequestWithBody(c.Server, modelId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemFilter(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, body ItemFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemFilterRequest(c.Server, modelId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreateWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateRequestWithBody(c.Server, modelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreate(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateRequest(c.Server, modelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemsAsCSV(ctx context.Context, modelId ModelIdParam, params *ItemsAsCSVParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemsAsCSVRequest(c.Server, modelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemsAsGeoJSON(ctx context.Context, modelId ModelIdParam, params *ItemsAsGeoJSONParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemsAsGeoJSONRequest(c.Server, modelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataSchemaByModelAsJSON(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataSchemaByModelAsJSONRequest(c.Server, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemaByModelAsJSON(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemaByModelAsJSONRequest(c.Server, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelFilter(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelFilterRequest(c.Server, projectIdOrAlias, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelCreateWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelCreateRequestWithBody(c.Server, projectIdOrAlias, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelCreate(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, body ModelCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelCreateRequest(c.Server, projectIdOrAlias, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelDeleteWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelDeleteWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelGetWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelGetWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelUpdateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelUpdateWithProjectRequestWithBody(c.Server, projectIdOrAlias, modelIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelUpdateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ModelUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelUpdateWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldCreateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldCreateWithProjectRequestWithBody(c.Server, projectIdOrAlias, modelIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldCreateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body FieldCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldCreateWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldDeleteWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldDeleteWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, fieldIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldUpdateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldUpdateWithProjectRequestWithBody(c.Server, projectIdOrAlias, modelIdOrKey, fieldIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldUpdateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldUpdateWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, fieldIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemFilterWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemFilterWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateWithProjectRequestWithBody(c.Server, projectIdOrAlias, modelIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemsWithProjectAsCSV(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsCSVParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemsWithProjectAsCSVRequest(c.Server, projectIdOrAlias, modelIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemsWithProjectAsGeoJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsGeoJSONParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemsWithProjectAsGeoJSONRequest(c.Server, projectIdOrAlias, modelIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataSchemaByModelWithProjectAsJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataSchemaByModelWithProjectAsJSONRequest(c.Server, projectIdOrAlias, modelIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemaByModelWithProjectAsJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemaByModelWithProjectAsJSONRequest(c.Server, projectIdOrAlias, modelIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemaFilter(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *SchemaFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemaFilterRequest(c.Server, projectIdOrAlias, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemaByIDWithProjectAsJSON(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemaByIDWithProjectAsJSONRequest(c.Server, projectIdOrAlias, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetFilter(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetFilterRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCreateWithBody(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCreateRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCreate(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCreateRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetUploadCreateWithBody(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetUploadCreateRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetUploadCreate(ctx context.Context, projectId ProjectIdParam, body AssetUploadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetUploadCreateRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldCreateWithBody(ctx context.Context, schemaId SchemaIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldCreateRequestWithBody(c.Server, schemaId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldCreate(ctx context.Context, schemaId SchemaIdParam, body FieldCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldCreateRequest(c.Server, schemaId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldDelete(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldDeleteRequest(c.Server, schemaId, fieldIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldUpdateWithBody(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldUpdateRequestWithBody(c.Server, schemaId, fieldIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FieldUpdate(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFieldUpdateRequest(c.Server, schemaId, fieldIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemaByIDAsJSON(ctx context.Context, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemaByIDAsJSONRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectFilter(ctx context.Context, workspaceId WorkspaceIdParam, params *ProjectFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectFilterRequest(c.Server, workspaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAssetDeleteRequest generates requests for AssetDelete
func NewAssetDeleteRequest(server string, assetId AssetIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetGetRequest generates requests for AssetGet
func NewAssetGetRequest(server string, assetId AssetIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCommentListRequest generates requests for AssetCommentList
func NewAssetCommentListRequest(server string, assetId AssetIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCommentCreateRequest calls the generic AssetCommentCreate builder with application/json body
func NewAssetCommentCreateRequest(server string, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetCommentCreateRequestWithBody(server, assetId, "application/json", bodyReader)
}

// NewAssetCommentCreateRequestWithBody generates requests for AssetCommentCreate with any type of body
func NewAssetCommentCreateRequestWithBody(server string, assetId AssetIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetCommentDeleteRequest generates requests for AssetCommentDelete
func NewAssetCommentDeleteRequest(server string, assetId AssetIdParam, commentId CommentIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCommentUpdateRequest calls the generic AssetCommentUpdate builder with application/json body
func NewAssetCommentUpdateRequest(server string, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetCommentUpdateRequestWithBody(server, assetId, commentId, "application/json", bodyReader)
}

// NewAssetCommentUpdateRequestWithBody generates requests for AssetCommentUpdate with any type of body
func NewAssetCommentUpdateRequestWithBody(server string, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemDeleteRequest generates requests for ItemDelete
func NewItemDeleteRequest(server string, itemId ItemIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemGetRequest generates requests for ItemGet
func NewItemGetRequest(server string, itemId ItemIdParam, params *ItemGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemUpdateRequest calls the generic ItemUpdate builder with application/json body
func NewItemUpdateRequest(server string, itemId ItemIdParam, body ItemUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemUpdateRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewItemUpdateRequestWithBody generates requests for ItemUpdate with any type of body
func NewItemUpdateRequestWithBody(server string, itemId ItemIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemCommentListRequest generates requests for ItemCommentList
func NewItemCommentListRequest(server string, itemId ItemIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemCommentCreateRequest calls the generic ItemCommentCreate builder with application/json body
func NewItemCommentCreateRequest(server string, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCommentCreateRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewItemCommentCreateRequestWithBody generates requests for ItemCommentCreate with any type of body
func NewItemCommentCreateRequestWithBody(server string, itemId ItemIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemCommentDeleteRequest generates requests for ItemCommentDelete
func NewItemCommentDeleteRequest(server string, itemId ItemIdParam, commentId CommentIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemCommentUpdateRequest calls the generic ItemCommentUpdate builder with application/json body
func NewItemCommentUpdateRequest(server string, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCommentUpdateRequestWithBody(server, itemId, commentId, "application/json", bodyReader)
}

// NewItemCommentUpdateRequestWithBody generates requests for ItemCommentUpdate with any type of body
func NewItemCommentUpdateRequestWithBody(server string, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelDeleteRequest generates requests for ModelDelete
func NewModelDeleteRequest(server string, modelId ModelIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelGetRequest generates requests for ModelGet
func NewModelGetRequest(server string, modelId ModelIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelUpdateRequest calls the generic ModelUpdate builder with application/json body
func NewModelUpdateRequest(server string, modelId ModelIdParam, body ModelUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelUpdateRequestWithBody(server, modelId, "application/json", bodyReader)
}

// NewModelUpdateRequestWithBody generates requests for ModelUpdate with any type of body
func NewModelUpdateRequestWithBody(server string, modelId ModelIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyModelRequest calls the generic CopyModel builder with application/json body
func NewCopyModelRequest(server string, modelId ModelIdParam, body CopyModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyModelRequestWithBody(server, modelId, "application/json", bodyReader)
}

// NewCopyModelRequestWithBody generates requests for CopyModel with any type of body
func NewCopyModelRequestWithBody(server string, modelId ModelIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/copy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelImportRequest calls the generic ModelImport builder with application/json body
func NewModelImportRequest(server string, modelId ModelIdParam, body ModelImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelImportRequestWithBody(server, modelId, "application/json", bodyReader)
}

// NewModelImportRequestWithBody generates requests for ModelImport with any type of body
func NewModelImportRequestWithBody(server string, modelId ModelIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/import", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemFilterRequest calls the generic ItemFilter builder with application/json body
func NewItemFilterRequest(server string, modelId ModelIdParam, params *ItemFilterParams, body ItemFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemFilterRequestWithBody(server, modelId, params, "application/json", bodyReader)
}

// NewItemFilterRequestWithBody generates requests for ItemFilter with any type of body
func NewItemFilterRequestWithBody(server string, modelId ModelIdParam, params *ItemFilterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dir", runtime.ParamLocationQuery, *params.Dir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemCreateRequest calls the generic ItemCreate builder with application/json body
func NewItemCreateRequest(server string, modelId ModelIdParam, body ItemCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCreateRequestWithBody(server, modelId, "application/json", bodyReader)
}

// NewItemCreateRequestWithBody generates requests for ItemCreate with any type of body
func NewItemCreateRequestWithBody(server string, modelId ModelIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemsAsCSVRequest generates requests for ItemsAsCSV
func NewItemsAsCSVRequest(server string, modelId ModelIdParam, params *ItemsAsCSVParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/items.csv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemsAsGeoJSONRequest generates requests for ItemsAsGeoJSON
func NewItemsAsGeoJSONRequest(server string, modelId ModelIdParam, params *ItemsAsGeoJSONParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/items.geojson", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataSchemaByModelAsJSONRequest generates requests for MetadataSchemaByModelAsJSON
func NewMetadataSchemaByModelAsJSONRequest(server string, modelId ModelIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/metadata_schema.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemaByModelAsJSONRequest generates requests for SchemaByModelAsJSON
func NewSchemaByModelAsJSONRequest(server string, modelId ModelIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/schema.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelFilterRequest generates requests for ModelFilter
func NewModelFilterRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, params *ModelFilterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelCreateRequest calls the generic ModelCreate builder with application/json body
func NewModelCreateRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, body ModelCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelCreateRequestWithBody(server, projectIdOrAlias, params, "application/json", bodyReader)
}

// NewModelCreateRequestWithBody generates requests for ModelCreate with any type of body
func NewModelCreateRequestWithBody(server string, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelDeleteWithProjectRequest generates requests for ModelDeleteWithProject
func NewModelDeleteWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelGetWithProjectRequest generates requests for ModelGetWithProject
func NewModelGetWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelUpdateWithProjectRequest calls the generic ModelUpdateWithProject builder with application/json body
func NewModelUpdateWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ModelUpdateWithProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelUpdateWithProjectRequestWithBody(server, projectIdOrAlias, modelIdOrKey, "application/json", bodyReader)
}

// NewModelUpdateWithProjectRequestWithBody generates requests for ModelUpdateWithProject with any type of body
func NewModelUpdateWithProjectRequestWithBody(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFieldCreateWithProjectRequest calls the generic FieldCreateWithProject builder with application/json body
func NewFieldCreateWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body FieldCreateWithProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFieldCreateWithProjectRequestWithBody(server, projectIdOrAlias, modelIdOrKey, "application/json", bodyReader)
}

// NewFieldCreateWithProjectRequestWithBody generates requests for FieldCreateWithProject with any type of body
func NewFieldCreateWithProjectRequestWithBody(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/fields", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFieldDeleteWithProjectRequest generates requests for FieldDeleteWithProject
func NewFieldDeleteWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "fieldIdOrKey", runtime.ParamLocationPath, fieldIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/fields/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFieldUpdateWithProjectRequest calls the generic FieldUpdateWithProject builder with application/json body
func NewFieldUpdateWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateWithProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFieldUpdateWithProjectRequestWithBody(server, projectIdOrAlias, modelIdOrKey, fieldIdOrKey, "application/json", bodyReader)
}

// NewFieldUpdateWithProjectRequestWithBody generates requests for FieldUpdateWithProject with any type of body
func NewFieldUpdateWithProjectRequestWithBody(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "fieldIdOrKey", runtime.ParamLocationPath, fieldIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/fields/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemFilterWithProjectRequest generates requests for ItemFilterWithProject
func NewItemFilterWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dir", runtime.ParamLocationQuery, *params.Dir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemCreateWithProjectRequest calls the generic ItemCreateWithProject builder with application/json body
func NewItemCreateWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCreateWithProjectRequestWithBody(server, projectIdOrAlias, modelIdOrKey, "application/json", bodyReader)
}

// NewItemCreateWithProjectRequestWithBody generates requests for ItemCreateWithProject with any type of body
func NewItemCreateWithProjectRequestWithBody(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemsWithProjectAsCSVRequest generates requests for ItemsWithProjectAsCSV
func NewItemsWithProjectAsCSVRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsCSVParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/items.csv", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemsWithProjectAsGeoJSONRequest generates requests for ItemsWithProjectAsGeoJSON
func NewItemsWithProjectAsGeoJSONRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsGeoJSONParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/items.geojson", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataSchemaByModelWithProjectAsJSONRequest generates requests for MetadataSchemaByModelWithProjectAsJSON
func NewMetadataSchemaByModelWithProjectAsJSONRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/metadata_schema.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemaByModelWithProjectAsJSONRequest generates requests for SchemaByModelWithProjectAsJSON
func NewSchemaByModelWithProjectAsJSONRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/schema.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemaFilterRequest generates requests for SchemaFilter
func NewSchemaFilterRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, params *SchemaFilterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/schemata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemaByIDWithProjectAsJSONRequest generates requests for SchemaByIDWithProjectAsJSON
func NewSchemaByIDWithProjectAsJSONRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, schemaId SchemaIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schemaId", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/schemata/%s/schema.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetFilterRequest generates requests for AssetFilter
func NewAssetFilterRequest(server string, projectId ProjectIdParam, params *AssetFilterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dir", runtime.ParamLocationQuery, *params.Dir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCreateRequest calls the generic AssetCreate builder with application/json body
func NewAssetCreateRequest(server string, projectId ProjectIdParam, body AssetCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetCreateRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewAssetCreateRequestWithBody generates requests for AssetCreate with any type of body
func NewAssetCreateRequestWithBody(server string, projectId ProjectIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetUploadCreateRequest calls the generic AssetUploadCreate builder with application/json body
func NewAssetUploadCreateRequest(server string, projectId ProjectIdParam, body AssetUploadCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetUploadCreateRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewAssetUploadCreateRequestWithBody generates requests for AssetUploadCreate with any type of body
func NewAssetUploadCreateRequestWithBody(server string, projectId ProjectIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/assets/uploads", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFieldCreateRequest calls the generic FieldCreate builder with application/json body
func NewFieldCreateRequest(server string, schemaId SchemaIdParam, body FieldCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFieldCreateRequestWithBody(server, schemaId, "application/json", bodyReader)
}

// NewFieldCreateRequestWithBody generates requests for FieldCreate with any type of body
func NewFieldCreateRequestWithBody(server string, schemaId SchemaIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schemaId", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemata/%s/fields", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFieldDeleteRequest generates requests for FieldDelete
func NewFieldDeleteRequest(server string, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schemaId", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fieldIdOrKey", runtime.ParamLocationPath, fieldIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemata/%s/fields/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFieldUpdateRequest calls the generic FieldUpdate builder with application/json body
func NewFieldUpdateRequest(server string, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFieldUpdateRequestWithBody(server, schemaId, fieldIdOrKey, "application/json", bodyReader)
}

// NewFieldUpdateRequestWithBody generates requests for FieldUpdate with any type of body
func NewFieldUpdateRequestWithBody(server string, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schemaId", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fieldIdOrKey", runtime.ParamLocationPath, fieldIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemata/%s/fields/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSchemaByIDAsJSONRequest generates requests for SchemaByIDAsJSON
func NewSchemaByIDAsJSONRequest(server string, schemaId SchemaIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schemaId", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemata/%s/schema.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectFilterRequest generates requests for ProjectFilter
func NewProjectFilterRequest(server string, workspaceId WorkspaceIdParam, params *ProjectFilterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AssetDeleteWithResponse request
	AssetDeleteWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetDeleteResponse, error)

	// AssetGetWithResponse request
	AssetGetWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetGetResponse, error)

	// AssetCommentListWithResponse request
	AssetCommentListWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetCommentListResponse, error)

	// AssetCommentCreateWithBodyWithResponse request with any body
	AssetCommentCreateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error)

	AssetCommentCreateWithResponse(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error)

	// AssetCommentDeleteWithResponse request
	AssetCommentDeleteWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*AssetCommentDeleteResponse, error)

	// AssetCommentUpdateWithBodyWithResponse request with any body
	AssetCommentUpdateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error)

	AssetCommentUpdateWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error)

	// ItemDeleteWithResponse request
	ItemDeleteWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error)

	// ItemGetWithResponse request
	ItemGetWithResponse(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*ItemGetResponse, error)

	// ItemUpdateWithBodyWithResponse request with any body
	ItemUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error)

	ItemUpdateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error)

	// ItemCommentListWithResponse request
	ItemCommentListWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemCommentListResponse, error)

	// ItemCommentCreateWithBodyWithResponse request with any body
	ItemCommentCreateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error)

	ItemCommentCreateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error)

	// ItemCommentDeleteWithResponse request
	ItemCommentDeleteWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*ItemCommentDeleteResponse, error)

	// ItemCommentUpdateWithBodyWithResponse request with any body
	ItemCommentUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error)

	ItemCommentUpdateWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error)

	// ModelDeleteWithResponse request
	ModelDeleteWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*ModelDeleteResponse, error)

	// ModelGetWithResponse request
	ModelGetWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*ModelGetResponse, error)

	// ModelUpdateWithBodyWithResponse request with any body
	ModelUpdateWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelUpdateResponse, error)

	ModelUpdateWithResponse(ctx context.Context, modelId ModelIdParam, body ModelUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelUpdateResponse, error)

	// CopyModelWithBodyWithResponse request with any body
	CopyModelWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyModelResponse, error)

	CopyModelWithResponse(ctx context.Context, modelId ModelIdParam, body CopyModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyModelResponse, error)

	// ModelImportWithBodyWithResponse request with any body
	ModelImportWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelImportResponse, error)

	ModelImportWithResponse(ctx context.Context, modelId ModelIdParam, body ModelImportJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelImportResponse, error)

	// ItemFilterWithBodyWithResponse request with any body
	ItemFilterWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemFilterResponse, error)

	ItemFilterWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, body ItemFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemFilterResponse, error)

	// ItemCreateWithBodyWithResponse request with any body
	ItemCreateWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error)

	ItemCreateWithResponse(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error)

	// ItemsAsCSVWithResponse request
	ItemsAsCSVWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemsAsCSVParams, reqEditors ...RequestEditorFn) (*ItemsAsCSVResponse, error)

	// ItemsAsGeoJSONWithResponse request
	ItemsAsGeoJSONWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemsAsGeoJSONParams, reqEditors ...RequestEditorFn) (*ItemsAsGeoJSONResponse, error)

	// MetadataSchemaByModelAsJSONWithResponse request
	MetadataSchemaByModelAsJSONWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*MetadataSchemaByModelAsJSONResponse, error)

	// SchemaByModelAsJSONWithResponse request
	SchemaByModelAsJSONWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*SchemaByModelAsJSONResponse, error)

	// ModelFilterWithResponse request
	ModelFilterWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelFilterParams, reqEditors ...RequestEditorFn) (*ModelFilterResponse, error)

	// ModelCreateWithBodyWithResponse request with any body
	ModelCreateWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelCreateResponse, error)

	ModelCreateWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, body ModelCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelCreateResponse, error)

	// ModelDeleteWithProjectWithResponse request
	ModelDeleteWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*ModelDeleteWithProjectResponse, error)

	// ModelGetWithProjectWithResponse request
	ModelGetWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*ModelGetWithProjectResponse, error)

	// ModelUpdateWithProjectWithBodyWithResponse request with any body
	ModelUpdateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelUpdateWithProjectResponse, error)

	ModelUpdateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ModelUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelUpdateWithProjectResponse, error)

	// FieldCreateWithProjectWithBodyWithResponse request with any body
	FieldCreateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldCreateWithProjectResponse, error)

	FieldCreateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body FieldCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldCreateWithProjectResponse, error)

	// FieldDeleteWithProjectWithResponse request
	FieldDeleteWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*FieldDeleteWithProjectResponse, error)

	// FieldUpdateWithProjectWithBodyWithResponse request with any body
	FieldUpdateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldUpdateWithProjectResponse, error)

	FieldUpdateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldUpdateWithProjectResponse, error)

	// ItemFilterWithProjectWithResponse request
	ItemFilterWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*ItemFilterWithProjectResponse, error)

	// ItemCreateWithProjectWithBodyWithResponse request with any body
	ItemCreateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error)

	ItemCreateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error)

	// ItemsWithProjectAsCSVWithResponse request
	ItemsWithProjectAsCSVWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsCSVParams, reqEditors ...RequestEditorFn) (*ItemsWithProjectAsCSVResponse, error)

	// ItemsWithProjectAsGeoJSONWithResponse request
	ItemsWithProjectAsGeoJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsGeoJSONParams, reqEditors ...RequestEditorFn) (*ItemsWithProjectAsGeoJSONResponse, error)

	// MetadataSchemaByModelWithProjectAsJSONWithResponse request
	MetadataSchemaByModelWithProjectAsJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*MetadataSchemaByModelWithProjectAsJSONResponse, error)

	// SchemaByModelWithProjectAsJSONWithResponse request
	SchemaByModelWithProjectAsJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*SchemaByModelWithProjectAsJSONResponse, error)

	// SchemaFilterWithResponse request
	SchemaFilterWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *SchemaFilterParams, reqEditors ...RequestEditorFn) (*SchemaFilterResponse, error)

	// SchemaByIDWithProjectAsJSONWithResponse request
	SchemaByIDWithProjectAsJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*SchemaByIDWithProjectAsJSONResponse, error)

	// AssetFilterWithResponse request
	AssetFilterWithResponse(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*AssetFilterResponse, error)

	// AssetCreateWithBodyWithResponse request with any body
	AssetCreateWithBodyWithResponse(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error)

	AssetCreateWithResponse(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error)

	// AssetUploadCreateWithBodyWithResponse request with any body
	AssetUploadCreateWithBodyWithResponse(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetUploadCreateResponse, error)

	AssetUploadCreateWithResponse(ctx context.Context, projectId ProjectIdParam, body AssetUploadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetUploadCreateResponse, error)

	// FieldCreateWithBodyWithResponse request with any body
	FieldCreateWithBodyWithResponse(ctx context.Context, schemaId SchemaIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldCreateResponse, error)

	FieldCreateWithResponse(ctx context.Context, schemaId SchemaIdParam, body FieldCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldCreateResponse, error)

	// FieldDeleteWithResponse request
	FieldDeleteWithResponse(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*FieldDeleteResponse, error)

	// FieldUpdateWithBodyWithResponse request with any body
	FieldUpdateWithBodyWithResponse(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldUpdateResponse, error)

	FieldUpdateWithResponse(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldUpdateResponse, error)

	// SchemaByIDAsJSONWithResponse request
	SchemaByIDAsJSONWithResponse(ctx context.Context, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*SchemaByIDAsJSONResponse, error)

	// ProjectFilterWithResponse request
	ProjectFilterWithResponse(ctx context.Context, workspaceId WorkspaceIdParam, params *ProjectFilterParams, reqEditors ...RequestEditorFn) (*ProjectFilterResponse, error)
}

type AssetDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Asset
}

// Status returns HTTPResponse.Status
func (r AssetGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Comments *[]Comment `json:"comments,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetCommentListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r AssetCommentCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetCommentDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r AssetCommentUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Comments *[]Comment `json:"comments,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemCommentListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r ItemCommentCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemCommentDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r ItemCommentUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ModelDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r ModelGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r ModelUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r CopyModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IgnoredCount  *int           `json:"ignoredCount,omitempty"`
		InsertedCount *int           `json:"insertedCount,omitempty"`
		ItemsCount    *int           `json:"itemsCount,omitempty"`
		ModelId       *string        `json:"modelId,omitempty"`
		NewFields     *[]SchemaField `json:"newFields,omitempty"`
		UpdatedCount  *int           `json:"updatedCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ModelImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items      *[]VersionedItem `json:"items,omitempty"`
		Page       *int             `json:"page,omitempty"`
		PerPage    *int             `json:"perPage,omitempty"`
		TotalCount *int             `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemsAsCSVResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ItemsAsCSVResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemsAsCSVResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemsAsGeoJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeoJSON
}

// Status returns HTTPResponse.Status
func (r ItemsAsGeoJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemsAsGeoJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataSchemaByModelAsJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaJSON
}

// Status returns HTTPResponse.Status
func (r MetadataSchemaByModelAsJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataSchemaByModelAsJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemaByModelAsJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaJSON
}

// Status returns HTTPResponse.Status
func (r SchemaByModelAsJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemaByModelAsJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Models     *[]Model `json:"models,omitempty"`
		Page       *int     `json:"page,omitempty"`
		PerPage    *int     `json:"perPage,omitempty"`
		TotalCount *int     `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ModelFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r ModelCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelDeleteWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ModelDeleteWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelDeleteWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelGetWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r ModelGetWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelGetWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelUpdateWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r ModelUpdateWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelUpdateWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FieldCreateWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaField
}

// Status returns HTTPResponse.Status
func (r FieldCreateWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FieldCreateWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FieldDeleteWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FieldDeleteWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FieldDeleteWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FieldUpdateWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaField
}

// Status returns HTTPResponse.Status
func (r FieldUpdateWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FieldUpdateWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemFilterWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items      *[]VersionedItem `json:"items,omitempty"`
		Page       *int             `json:"page,omitempty"`
		PerPage    *int             `json:"perPage,omitempty"`
		TotalCount *int             `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemFilterWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemFilterWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCreateWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemCreateWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCreateWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemsWithProjectAsCSVResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ItemsWithProjectAsCSVResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemsWithProjectAsCSVResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemsWithProjectAsGeoJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeoJSON
}

// Status returns HTTPResponse.Status
func (r ItemsWithProjectAsGeoJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemsWithProjectAsGeoJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataSchemaByModelWithProjectAsJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaJSON
}

// Status returns HTTPResponse.Status
func (r MetadataSchemaByModelWithProjectAsJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataSchemaByModelWithProjectAsJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemaByModelWithProjectAsJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaJSON
}

// Status returns HTTPResponse.Status
func (r SchemaByModelWithProjectAsJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemaByModelWithProjectAsJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemaFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Models     *[]Model `json:"models,omitempty"`
		Page       *int     `json:"page,omitempty"`
		PerPage    *int     `json:"perPage,omitempty"`
		TotalCount *int     `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SchemaFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemaFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemaByIDWithProjectAsJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaJSON
}

// Status returns HTTPResponse.Status
func (r SchemaByIDWithProjectAsJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemaByIDWithProjectAsJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items      *[]Asset `json:"items,omitempty"`
		Page       *int     `json:"page,omitempty"`
		PerPage    *int     `json:"perPage,omitempty"`
		TotalCount *int     `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Asset
}

// Status returns HTTPResponse.Status
func (r AssetCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetUploadCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ContentLength *int    `json:"contentLength,omitempty"`
		ContentType   *string `json:"contentType,omitempty"`
		Next          *string `json:"next,omitempty"`
		Token         *string `json:"token,omitempty"`
		Url           *string `json:"url,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetUploadCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetUploadCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FieldCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaField
}

// Status returns HTTPResponse.Status
func (r FieldCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FieldCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FieldDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FieldDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FieldDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FieldUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaField
}

// Status returns HTTPResponse.Status
func (r FieldUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FieldUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemaByIDAsJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaJSON
}

// Status returns HTTPResponse.Status
func (r SchemaByIDAsJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemaByIDAsJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page       *int       `json:"page,omitempty"`
		PerPage    *int       `json:"perPage,omitempty"`
		Projects   *[]Project `json:"projects,omitempty"`
		TotalCount *int       `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AssetDeleteWithResponse request returning *AssetDeleteResponse
func (c *ClientWithResponses) AssetDeleteWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetDeleteResponse, error) {
	rsp, err := c.AssetDelete(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetDeleteResponse(rsp)
}

// AssetGetWithResponse request returning *AssetGetResponse
func (c *ClientWithResponses) AssetGetWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetGetResponse, error) {
	rsp, err := c.AssetGet(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetGetResponse(rsp)
}

// AssetCommentListWithResponse request returning *AssetCommentListResponse
func (c *ClientWithResponses) AssetCommentListWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetCommentListResponse, error) {
	rsp, err := c.AssetCommentList(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentListResponse(rsp)
}

// AssetCommentCreateWithBodyWithResponse request with arbitrary body returning *AssetCommentCreateResponse
func (c *ClientWithResponses) AssetCommentCreateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error) {
	rsp, err := c.AssetCommentCreateWithBody(ctx, assetId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentCreateResponse(rsp)
}

func (c *ClientWithResponses) AssetCommentCreateWithResponse(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error) {
	rsp, err := c.AssetCommentCreate(ctx, assetId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentCreateResponse(rsp)
}

// AssetCommentDeleteWithResponse request returning *AssetCommentDeleteResponse
func (c *ClientWithResponses) AssetCommentDeleteWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*AssetCommentDeleteResponse, error) {
	rsp, err := c.AssetCommentDelete(ctx, assetId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentDeleteResponse(rsp)
}

// AssetCommentUpdateWithBodyWithResponse request with arbitrary body returning *AssetCommentUpdateResponse
func (c *ClientWithResponses) AssetCommentUpdateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error) {
	rsp, err := c.AssetCommentUpdateWithBody(ctx, assetId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentUpdateResponse(rsp)
}

func (c *ClientWithResponses) AssetCommentUpdateWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error) {
	rsp, err := c.AssetCommentUpdate(ctx, assetId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentUpdateResponse(rsp)
}

// ItemDeleteWithResponse request returning *ItemDeleteResponse
func (c *ClientWithResponses) ItemDeleteWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error) {
	rsp, err := c.ItemDelete(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemDeleteResponse(rsp)
}

// ItemGetWithResponse request returning *ItemGetResponse
func (c *ClientWithResponses) ItemGetWithResponse(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*ItemGetResponse, error) {
	rsp, err := c.ItemGet(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemGetResponse(rsp)
}

// ItemUpdateWithBodyWithResponse request with arbitrary body returning *ItemUpdateResponse
func (c *ClientWithResponses) ItemUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error) {
	rsp, err := c.ItemUpdateWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemUpdateResponse(rsp)
}

func (c *ClientWithResponses) ItemUpdateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error) {
	rsp, err := c.ItemUpdate(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemUpdateResponse(rsp)
}

// ItemCommentListWithResponse request returning *ItemCommentListResponse
func (c *ClientWithResponses) ItemCommentListWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemCommentListResponse, error) {
	rsp, err := c.ItemCommentList(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentListResponse(rsp)
}

// ItemCommentCreateWithBodyWithResponse request with arbitrary body returning *ItemCommentCreateResponse
func (c *ClientWithResponses) ItemCommentCreateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error) {
	rsp, err := c.ItemCommentCreateWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentCreateResponse(rsp)
}

func (c *ClientWithResponses) ItemCommentCreateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error) {
	rsp, err := c.ItemCommentCreate(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentCreateResponse(rsp)
}

// ItemCommentDeleteWithResponse request returning *ItemCommentDeleteResponse
func (c *ClientWithResponses) ItemCommentDeleteWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*ItemCommentDeleteResponse, error) {
	rsp, err := c.ItemCommentDelete(ctx, itemId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentDeleteResponse(rsp)
}

// ItemCommentUpdateWithBodyWithResponse request with arbitrary body returning *ItemCommentUpdateResponse
func (c *ClientWithResponses) ItemCommentUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error) {
	rsp, err := c.ItemCommentUpdateWithBody(ctx, itemId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentUpdateResponse(rsp)
}

func (c *ClientWithResponses) ItemCommentUpdateWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error) {
	rsp, err := c.ItemCommentUpdate(ctx, itemId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentUpdateResponse(rsp)
}

// ModelDeleteWithResponse request returning *ModelDeleteResponse
func (c *ClientWithResponses) ModelDeleteWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*ModelDeleteResponse, error) {
	rsp, err := c.ModelDelete(ctx, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelDeleteResponse(rsp)
}

// ModelGetWithResponse request returning *ModelGetResponse
func (c *ClientWithResponses) ModelGetWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*ModelGetResponse, error) {
	rsp, err := c.ModelGet(ctx, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelGetResponse(rsp)
}

// ModelUpdateWithBodyWithResponse request with arbitrary body returning *ModelUpdateResponse
func (c *ClientWithResponses) ModelUpdateWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelUpdateResponse, error) {
	rsp, err := c.ModelUpdateWithBody(ctx, modelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelUpdateResponse(rsp)
}

func (c *ClientWithResponses) ModelUpdateWithResponse(ctx context.Context, modelId ModelIdParam, body ModelUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelUpdateResponse, error) {
	rsp, err := c.ModelUpdate(ctx, modelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelUpdateResponse(rsp)
}

// CopyModelWithBodyWithResponse request with arbitrary body returning *CopyModelResponse
func (c *ClientWithResponses) CopyModelWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyModelResponse, error) {
	rsp, err := c.CopyModelWithBody(ctx, modelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyModelResponse(rsp)
}

func (c *ClientWithResponses) CopyModelWithResponse(ctx context.Context, modelId ModelIdParam, body CopyModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyModelResponse, error) {
	rsp, err := c.CopyModel(ctx, modelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyModelResponse(rsp)
}

// ModelImportWithBodyWithResponse request with arbitrary body returning *ModelImportResponse
func (c *ClientWithResponses) ModelImportWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelImportResponse, error) {
	rsp, err := c.ModelImportWithBody(ctx, modelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelImportResponse(rsp)
}

func (c *ClientWithResponses) ModelImportWithResponse(ctx context.Context, modelId ModelIdParam, body ModelImportJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelImportResponse, error) {
	rsp, err := c.ModelImport(ctx, modelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelImportResponse(rsp)
}

// ItemFilterWithBodyWithResponse request with arbitrary body returning *ItemFilterResponse
func (c *ClientWithResponses) ItemFilterWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemFilterResponse, error) {
	rsp, err := c.ItemFilterWithBody(ctx, modelId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemFilterResponse(rsp)
}

func (c *ClientWithResponses) ItemFilterWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, body ItemFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemFilterResponse, error) {
	rsp, err := c.ItemFilter(ctx, modelId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemFilterResponse(rsp)
}

// ItemCreateWithBodyWithResponse request with arbitrary body returning *ItemCreateResponse
func (c *ClientWithResponses) ItemCreateWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error) {
	rsp, err := c.ItemCreateWithBody(ctx, modelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateResponse(rsp)
}

func (c *ClientWithResponses) ItemCreateWithResponse(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error) {
	rsp, err := c.ItemCreate(ctx, modelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateResponse(rsp)
}

// ItemsAsCSVWithResponse request returning *ItemsAsCSVResponse
func (c *ClientWithResponses) ItemsAsCSVWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemsAsCSVParams, reqEditors ...RequestEditorFn) (*ItemsAsCSVResponse, error) {
	rsp, err := c.ItemsAsCSV(ctx, modelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemsAsCSVResponse(rsp)
}

// ItemsAsGeoJSONWithResponse request returning *ItemsAsGeoJSONResponse
func (c *ClientWithResponses) ItemsAsGeoJSONWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemsAsGeoJSONParams, reqEditors ...RequestEditorFn) (*ItemsAsGeoJSONResponse, error) {
	rsp, err := c.ItemsAsGeoJSON(ctx, modelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemsAsGeoJSONResponse(rsp)
}

// MetadataSchemaByModelAsJSONWithResponse request returning *MetadataSchemaByModelAsJSONResponse
func (c *ClientWithResponses) MetadataSchemaByModelAsJSONWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*MetadataSchemaByModelAsJSONResponse, error) {
	rsp, err := c.MetadataSchemaByModelAsJSON(ctx, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataSchemaByModelAsJSONResponse(rsp)
}

// SchemaByModelAsJSONWithResponse request returning *SchemaByModelAsJSONResponse
func (c *ClientWithResponses) SchemaByModelAsJSONWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*SchemaByModelAsJSONResponse, error) {
	rsp, err := c.SchemaByModelAsJSON(ctx, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemaByModelAsJSONResponse(rsp)
}

// ModelFilterWithResponse request returning *ModelFilterResponse
func (c *ClientWithResponses) ModelFilterWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelFilterParams, reqEditors ...RequestEditorFn) (*ModelFilterResponse, error) {
	rsp, err := c.ModelFilter(ctx, projectIdOrAlias, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelFilterResponse(rsp)
}

// ModelCreateWithBodyWithResponse request with arbitrary body returning *ModelCreateResponse
func (c *ClientWithResponses) ModelCreateWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelCreateResponse, error) {
	rsp, err := c.ModelCreateWithBody(ctx, projectIdOrAlias, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelCreateResponse(rsp)
}

func (c *ClientWithResponses) ModelCreateWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *ModelCreateParams, body ModelCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelCreateResponse, error) {
	rsp, err := c.ModelCreate(ctx, projectIdOrAlias, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelCreateResponse(rsp)
}

// ModelDeleteWithProjectWithResponse request returning *ModelDeleteWithProjectResponse
func (c *ClientWithResponses) ModelDeleteWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*ModelDeleteWithProjectResponse, error) {
	rsp, err := c.ModelDeleteWithProject(ctx, projectIdOrAlias, modelIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelDeleteWithProjectResponse(rsp)
}

// ModelGetWithProjectWithResponse request returning *ModelGetWithProjectResponse
func (c *ClientWithResponses) ModelGetWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*ModelGetWithProjectResponse, error) {
	rsp, err := c.ModelGetWithProject(ctx, projectIdOrAlias, modelIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelGetWithProjectResponse(rsp)
}

// ModelUpdateWithProjectWithBodyWithResponse request with arbitrary body returning *ModelUpdateWithProjectResponse
func (c *ClientWithResponses) ModelUpdateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelUpdateWithProjectResponse, error) {
	rsp, err := c.ModelUpdateWithProjectWithBody(ctx, projectIdOrAlias, modelIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelUpdateWithProjectResponse(rsp)
}

func (c *ClientWithResponses) ModelUpdateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ModelUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelUpdateWithProjectResponse, error) {
	rsp, err := c.ModelUpdateWithProject(ctx, projectIdOrAlias, modelIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelUpdateWithProjectResponse(rsp)
}

// FieldCreateWithProjectWithBodyWithResponse request with arbitrary body returning *FieldCreateWithProjectResponse
func (c *ClientWithResponses) FieldCreateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldCreateWithProjectResponse, error) {
	rsp, err := c.FieldCreateWithProjectWithBody(ctx, projectIdOrAlias, modelIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldCreateWithProjectResponse(rsp)
}

func (c *ClientWithResponses) FieldCreateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body FieldCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldCreateWithProjectResponse, error) {
	rsp, err := c.FieldCreateWithProject(ctx, projectIdOrAlias, modelIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldCreateWithProjectResponse(rsp)
}

// FieldDeleteWithProjectWithResponse request returning *FieldDeleteWithProjectResponse
func (c *ClientWithResponses) FieldDeleteWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*FieldDeleteWithProjectResponse, error) {
	rsp, err := c.FieldDeleteWithProject(ctx, projectIdOrAlias, modelIdOrKey, fieldIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldDeleteWithProjectResponse(rsp)
}

// FieldUpdateWithProjectWithBodyWithResponse request with arbitrary body returning *FieldUpdateWithProjectResponse
func (c *ClientWithResponses) FieldUpdateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldUpdateWithProjectResponse, error) {
	rsp, err := c.FieldUpdateWithProjectWithBody(ctx, projectIdOrAlias, modelIdOrKey, fieldIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldUpdateWithProjectResponse(rsp)
}

func (c *ClientWithResponses) FieldUpdateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldUpdateWithProjectResponse, error) {
	rsp, err := c.FieldUpdateWithProject(ctx, projectIdOrAlias, modelIdOrKey, fieldIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldUpdateWithProjectResponse(rsp)
}

// ItemFilterWithProjectWithResponse request returning *ItemFilterWithProjectResponse
func (c *ClientWithResponses) ItemFilterWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*ItemFilterWithProjectResponse, error) {
	rsp, err := c.ItemFilterWithProject(ctx, projectIdOrAlias, modelIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemFilterWithProjectResponse(rsp)
}

// ItemCreateWithProjectWithBodyWithResponse request with arbitrary body returning *ItemCreateWithProjectResponse
func (c *ClientWithResponses) ItemCreateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error) {
	rsp, err := c.ItemCreateWithProjectWithBody(ctx, projectIdOrAlias, modelIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateWithProjectResponse(rsp)
}

func (c *ClientWithResponses) ItemCreateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error) {
	rsp, err := c.ItemCreateWithProject(ctx, projectIdOrAlias, modelIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateWithProjectResponse(rsp)
}

// ItemsWithProjectAsCSVWithResponse request returning *ItemsWithProjectAsCSVResponse
func (c *ClientWithResponses) ItemsWithProjectAsCSVWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsCSVParams, reqEditors ...RequestEditorFn) (*ItemsWithProjectAsCSVResponse, error) {
	rsp, err := c.ItemsWithProjectAsCSV(ctx, projectIdOrAlias, modelIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemsWithProjectAsCSVResponse(rsp)
}

// ItemsWithProjectAsGeoJSONWithResponse request returning *ItemsWithProjectAsGeoJSONResponse
func (c *ClientWithResponses) ItemsWithProjectAsGeoJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemsWithProjectAsGeoJSONParams, reqEditors ...RequestEditorFn) (*ItemsWithProjectAsGeoJSONResponse, error) {
	rsp, err := c.ItemsWithProjectAsGeoJSON(ctx, projectIdOrAlias, modelIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemsWithProjectAsGeoJSONResponse(rsp)
}

// MetadataSchemaByModelWithProjectAsJSONWithResponse request returning *MetadataSchemaByModelWithProjectAsJSONResponse
func (c *ClientWithResponses) MetadataSchemaByModelWithProjectAsJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*MetadataSchemaByModelWithProjectAsJSONResponse, error) {
	rsp, err := c.MetadataSchemaByModelWithProjectAsJSON(ctx, projectIdOrAlias, modelIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataSchemaByModelWithProjectAsJSONResponse(rsp)
}

// SchemaByModelWithProjectAsJSONWithResponse request returning *SchemaByModelWithProjectAsJSONResponse
func (c *ClientWithResponses) SchemaByModelWithProjectAsJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*SchemaByModelWithProjectAsJSONResponse, error) {
	rsp, err := c.SchemaByModelWithProjectAsJSON(ctx, projectIdOrAlias, modelIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemaByModelWithProjectAsJSONResponse(rsp)
}

// SchemaFilterWithResponse request returning *SchemaFilterResponse
func (c *ClientWithResponses) SchemaFilterWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, params *SchemaFilterParams, reqEditors ...RequestEditorFn) (*SchemaFilterResponse, error) {
	rsp, err := c.SchemaFilter(ctx, projectIdOrAlias, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemaFilterResponse(rsp)
}

// SchemaByIDWithProjectAsJSONWithResponse request returning *SchemaByIDWithProjectAsJSONResponse
func (c *ClientWithResponses) SchemaByIDWithProjectAsJSONWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*SchemaByIDWithProjectAsJSONResponse, error) {
	rsp, err := c.SchemaByIDWithProjectAsJSON(ctx, projectIdOrAlias, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemaByIDWithProjectAsJSONResponse(rsp)
}

// AssetFilterWithResponse request returning *AssetFilterResponse
func (c *ClientWithResponses) AssetFilterWithResponse(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*AssetFilterResponse, error) {
	rsp, err := c.AssetFilter(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetFilterResponse(rsp)
}

// AssetCreateWithBodyWithResponse request with arbitrary body returning *AssetCreateResponse
func (c *ClientWithResponses) AssetCreateWithBodyWithResponse(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error) {
	rsp, err := c.AssetCreateWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCreateResponse(rsp)
}

func (c *ClientWithResponses) AssetCreateWithResponse(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error) {
	rsp, err := c.AssetCreate(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCreateResponse(rsp)
}

// AssetUploadCreateWithBodyWithResponse request with arbitrary body returning *AssetUploadCreateResponse
func (c *ClientWithResponses) AssetUploadCreateWithBodyWithResponse(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetUploadCreateResponse, error) {
	rsp, err := c.AssetUploadCreateWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetUploadCreateResponse(rsp)
}

func (c *ClientWithResponses) AssetUploadCreateWithResponse(ctx context.Context, projectId ProjectIdParam, body AssetUploadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetUploadCreateResponse, error) {
	rsp, err := c.AssetUploadCreate(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetUploadCreateResponse(rsp)
}

// FieldCreateWithBodyWithResponse request with arbitrary body returning *FieldCreateResponse
func (c *ClientWithResponses) FieldCreateWithBodyWithResponse(ctx context.Context, schemaId SchemaIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldCreateResponse, error) {
	rsp, err := c.FieldCreateWithBody(ctx, schemaId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldCreateResponse(rsp)
}

func (c *ClientWithResponses) FieldCreateWithResponse(ctx context.Context, schemaId SchemaIdParam, body FieldCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldCreateResponse, error) {
	rsp, err := c.FieldCreate(ctx, schemaId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldCreateResponse(rsp)
}

// FieldDeleteWithResponse request returning *FieldDeleteResponse
func (c *ClientWithResponses) FieldDeleteWithResponse(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, reqEditors ...RequestEditorFn) (*FieldDeleteResponse, error) {
	rsp, err := c.FieldDelete(ctx, schemaId, fieldIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldDeleteResponse(rsp)
}

// FieldUpdateWithBodyWithResponse request with arbitrary body returning *FieldUpdateResponse
func (c *ClientWithResponses) FieldUpdateWithBodyWithResponse(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FieldUpdateResponse, error) {
	rsp, err := c.FieldUpdateWithBody(ctx, schemaId, fieldIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldUpdateResponse(rsp)
}

func (c *ClientWithResponses) FieldUpdateWithResponse(ctx context.Context, schemaId SchemaIdParam, fieldIdOrKey FieldIdOrKeyParam, body FieldUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FieldUpdateResponse, error) {
	rsp, err := c.FieldUpdate(ctx, schemaId, fieldIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFieldUpdateResponse(rsp)
}

// SchemaByIDAsJSONWithResponse request returning *SchemaByIDAsJSONResponse
func (c *ClientWithResponses) SchemaByIDAsJSONWithResponse(ctx context.Context, schemaId SchemaIdParam, reqEditors ...RequestEditorFn) (*SchemaByIDAsJSONResponse, error) {
	rsp, err := c.SchemaByIDAsJSON(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemaByIDAsJSONResponse(rsp)
}

// ProjectFilterWithResponse request returning *ProjectFilterResponse
func (c *ClientWithResponses) ProjectFilterWithResponse(ctx context.Context, workspaceId WorkspaceIdParam, params *ProjectFilterParams, reqEditors ...RequestEditorFn) (*ProjectFilterResponse, error) {
	rsp, err := c.ProjectFilter(ctx, workspaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectFilterResponse(rsp)
}

// ParseAssetDeleteResponse parses an HTTP response from a AssetDeleteWithResponse call
func ParseAssetDeleteResponse(rsp *http.Response) (*AssetDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetGetResponse parses an HTTP response from a AssetGetWithResponse call
func ParseAssetGetResponse(rsp *http.Response) (*AssetGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Asset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentListResponse parses an HTTP response from a AssetCommentListWithResponse call
func ParseAssetCommentListResponse(rsp *http.Response) (*AssetCommentListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Comments *[]Comment `json:"comments,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentCreateResponse parses an HTTP response from a AssetCommentCreateWithResponse call
func ParseAssetCommentCreateResponse(rsp *http.Response) (*AssetCommentCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentDeleteResponse parses an HTTP response from a AssetCommentDeleteWithResponse call
func ParseAssetCommentDeleteResponse(rsp *http.Response) (*AssetCommentDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentUpdateResponse parses an HTTP response from a AssetCommentUpdateWithResponse call
func ParseAssetCommentUpdateResponse(rsp *http.Response) (*AssetCommentUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemDeleteResponse parses an HTTP response from a ItemDeleteWithResponse call
func ParseItemDeleteResponse(rsp *http.Response) (*ItemDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemGetResponse parses an HTTP response from a ItemGetWithResponse call
func ParseItemGetResponse(rsp *http.Response) (*ItemGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemUpdateResponse parses an HTTP response from a ItemUpdateWithResponse call
func ParseItemUpdateResponse(rsp *http.Response) (*ItemUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentListResponse parses an HTTP response from a ItemCommentListWithResponse call
func ParseItemCommentListResponse(rsp *http.Response) (*ItemCommentListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Comments *[]Comment `json:"comments,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentCreateResponse parses an HTTP response from a ItemCommentCreateWithResponse call
func ParseItemCommentCreateResponse(rsp *http.Response) (*ItemCommentCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentDeleteResponse parses an HTTP response from a ItemCommentDeleteWithResponse call
func ParseItemCommentDeleteResponse(rsp *http.Response) (*ItemCommentDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentUpdateResponse parses an HTTP response from a ItemCommentUpdateWithResponse call
func ParseItemCommentUpdateResponse(rsp *http.Response) (*ItemCommentUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelDeleteResponse parses an HTTP response from a ModelDeleteWithResponse call
func ParseModelDeleteResponse(rsp *http.Response) (*ModelDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelGetResponse parses an HTTP response from a ModelGetWithResponse call
func ParseModelGetResponse(rsp *http.Response) (*ModelGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelUpdateResponse parses an HTTP response from a ModelUpdateWithResponse call
func ParseModelUpdateResponse(rsp *http.Response) (*ModelUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCopyModelResponse parses an HTTP response from a CopyModelWithResponse call
func ParseCopyModelResponse(rsp *http.Response) (*CopyModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelImportResponse parses an HTTP response from a ModelImportWithResponse call
func ParseModelImportResponse(rsp *http.Response) (*ModelImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IgnoredCount  *int           `json:"ignoredCount,omitempty"`
			InsertedCount *int           `json:"insertedCount,omitempty"`
			ItemsCount    *int           `json:"itemsCount,omitempty"`
			ModelId       *string        `json:"modelId,omitempty"`
			NewFields     *[]SchemaField `json:"newFields,omitempty"`
			UpdatedCount  *int           `json:"updatedCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemFilterResponse parses an HTTP response from a ItemFilterWithResponse call
func ParseItemFilterResponse(rsp *http.Response) (*ItemFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items      *[]VersionedItem `json:"items,omitempty"`
			Page       *int             `json:"page,omitempty"`
			PerPage    *int             `json:"perPage,omitempty"`
			TotalCount *int             `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCreateResponse parses an HTTP response from a ItemCreateWithResponse call
func ParseItemCreateResponse(rsp *http.Response) (*ItemCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemsAsCSVResponse parses an HTTP response from a ItemsAsCSVWithResponse call
func ParseItemsAsCSVResponse(rsp *http.Response) (*ItemsAsCSVResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemsAsCSVResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseItemsAsGeoJSONResponse parses an HTTP response from a ItemsAsGeoJSONWithResponse call
func ParseItemsAsGeoJSONResponse(rsp *http.Response) (*ItemsAsGeoJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemsAsGeoJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeoJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetadataSchemaByModelAsJSONResponse parses an HTTP response from a MetadataSchemaByModelAsJSONWithResponse call
func ParseMetadataSchemaByModelAsJSONResponse(rsp *http.Response) (*MetadataSchemaByModelAsJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataSchemaByModelAsJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemaByModelAsJSONResponse parses an HTTP response from a SchemaByModelAsJSONWithResponse call
func ParseSchemaByModelAsJSONResponse(rsp *http.Response) (*SchemaByModelAsJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemaByModelAsJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelFilterResponse parses an HTTP response from a ModelFilterWithResponse call
func ParseModelFilterResponse(rsp *http.Response) (*ModelFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Models     *[]Model `json:"models,omitempty"`
			Page       *int     `json:"page,omitempty"`
			PerPage    *int     `json:"perPage,omitempty"`
			TotalCount *int     `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelCreateResponse parses an HTTP response from a ModelCreateWithResponse call
func ParseModelCreateResponse(rsp *http.Response) (*ModelCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelDeleteWithProjectResponse parses an HTTP response from a ModelDeleteWithProjectWithResponse call
func ParseModelDeleteWithProjectResponse(rsp *http.Response) (*ModelDeleteWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelDeleteWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelGetWithProjectResponse parses an HTTP response from a ModelGetWithProjectWithResponse call
func ParseModelGetWithProjectResponse(rsp *http.Response) (*ModelGetWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelGetWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelUpdateWithProjectResponse parses an HTTP response from a ModelUpdateWithProjectWithResponse call
func ParseModelUpdateWithProjectResponse(rsp *http.Response) (*ModelUpdateWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelUpdateWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFieldCreateWithProjectResponse parses an HTTP response from a FieldCreateWithProjectWithResponse call
func ParseFieldCreateWithProjectResponse(rsp *http.Response) (*FieldCreateWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FieldCreateWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaField
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFieldDeleteWithProjectResponse parses an HTTP response from a FieldDeleteWithProjectWithResponse call
func ParseFieldDeleteWithProjectResponse(rsp *http.Response) (*FieldDeleteWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FieldDeleteWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFieldUpdateWithProjectResponse parses an HTTP response from a FieldUpdateWithProjectWithResponse call
func ParseFieldUpdateWithProjectResponse(rsp *http.Response) (*FieldUpdateWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FieldUpdateWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaField
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemFilterWithProjectResponse parses an HTTP response from a ItemFilterWithProjectWithResponse call
func ParseItemFilterWithProjectResponse(rsp *http.Response) (*ItemFilterWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemFilterWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items      *[]VersionedItem `json:"items,omitempty"`
			Page       *int             `json:"page,omitempty"`
			PerPage    *int             `json:"perPage,omitempty"`
			TotalCount *int             `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCreateWithProjectResponse parses an HTTP response from a ItemCreateWithProjectWithResponse call
func ParseItemCreateWithProjectResponse(rsp *http.Response) (*ItemCreateWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCreateWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemsWithProjectAsCSVResponse parses an HTTP response from a ItemsWithProjectAsCSVWithResponse call
func ParseItemsWithProjectAsCSVResponse(rsp *http.Response) (*ItemsWithProjectAsCSVResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemsWithProjectAsCSVResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseItemsWithProjectAsGeoJSONResponse parses an HTTP response from a ItemsWithProjectAsGeoJSONWithResponse call
func ParseItemsWithProjectAsGeoJSONResponse(rsp *http.Response) (*ItemsWithProjectAsGeoJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemsWithProjectAsGeoJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeoJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetadataSchemaByModelWithProjectAsJSONResponse parses an HTTP response from a MetadataSchemaByModelWithProjectAsJSONWithResponse call
func ParseMetadataSchemaByModelWithProjectAsJSONResponse(rsp *http.Response) (*MetadataSchemaByModelWithProjectAsJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataSchemaByModelWithProjectAsJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemaByModelWithProjectAsJSONResponse parses an HTTP response from a SchemaByModelWithProjectAsJSONWithResponse call
func ParseSchemaByModelWithProjectAsJSONResponse(rsp *http.Response) (*SchemaByModelWithProjectAsJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemaByModelWithProjectAsJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemaFilterResponse parses an HTTP response from a SchemaFilterWithResponse call
func ParseSchemaFilterResponse(rsp *http.Response) (*SchemaFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemaFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Models     *[]Model `json:"models,omitempty"`
			Page       *int     `json:"page,omitempty"`
			PerPage    *int     `json:"perPage,omitempty"`
			TotalCount *int     `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemaByIDWithProjectAsJSONResponse parses an HTTP response from a SchemaByIDWithProjectAsJSONWithResponse call
func ParseSchemaByIDWithProjectAsJSONResponse(rsp *http.Response) (*SchemaByIDWithProjectAsJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemaByIDWithProjectAsJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetFilterResponse parses an HTTP response from a AssetFilterWithResponse call
func ParseAssetFilterResponse(rsp *http.Response) (*AssetFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items      *[]Asset `json:"items,omitempty"`
			Page       *int     `json:"page,omitempty"`
			PerPage    *int     `json:"perPage,omitempty"`
			TotalCount *int     `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCreateResponse parses an HTTP response from a AssetCreateWithResponse call
func ParseAssetCreateResponse(rsp *http.Response) (*AssetCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Asset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetUploadCreateResponse parses an HTTP response from a AssetUploadCreateWithResponse call
func ParseAssetUploadCreateResponse(rsp *http.Response) (*AssetUploadCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetUploadCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ContentLength *int    `json:"contentLength,omitempty"`
			ContentType   *string `json:"contentType,omitempty"`
			Next          *string `json:"next,omitempty"`
			Token         *string `json:"token,omitempty"`
			Url           *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFieldCreateResponse parses an HTTP response from a FieldCreateWithResponse call
func ParseFieldCreateResponse(rsp *http.Response) (*FieldCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FieldCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaField
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFieldDeleteResponse parses an HTTP response from a FieldDeleteWithResponse call
func ParseFieldDeleteResponse(rsp *http.Response) (*FieldDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FieldDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFieldUpdateResponse parses an HTTP response from a FieldUpdateWithResponse call
func ParseFieldUpdateResponse(rsp *http.Response) (*FieldUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FieldUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaField
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemaByIDAsJSONResponse parses an HTTP response from a SchemaByIDAsJSONWithResponse call
func ParseSchemaByIDAsJSONResponse(rsp *http.Response) (*SchemaByIDAsJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemaByIDAsJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProjectFilterResponse parses an HTTP response from a ProjectFilterWithResponse call
func ParseProjectFilterResponse(rsp *http.Response) (*ProjectFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page       *int       `json:"page,omitempty"`
			PerPage    *int       `json:"perPage,omitempty"`
			Projects   *[]Project `json:"projects,omitempty"`
			TotalCount *int       `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
